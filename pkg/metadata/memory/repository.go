package memory

import (
	"crypto/sha256"
	"encoding/binary"
	"fmt"
	"sync"

	"github.com/marmos91/dittofs/pkg/metadata"
)

// Mount tracking key structure
type mountKey struct {
	exportPath string
	clientAddr string
}

// Export data structure
type exportData struct {
	Export     metadata.Export
	RootHandle metadata.FileHandle
}

// MemoryRepository implements Repository using in-memory storage.
//
// This implementation provides a fully functional NFS metadata repository
// backed by in-memory data structures. It is suitable for:
//   - Testing and development
//   - Ephemeral filesystems
//   - Caching layers
//   - Systems where persistence is handled externally
//
// Thread Safety:
// All operations are protected by a read-write mutex, making the repository
// safe for concurrent access from multiple goroutines.
//
// Storage Structure:
//   - exports: Map of export paths to export configurations
//   - files: Map of file handles to file attributes
//   - parents: Map of child handles to parent handles
//   - children: Map of parent handles to child name-handle mappings
//   - mounts: Map of client-export pairs to mount information
//
// Handle Generation:
// File handles are generated using SHA-256 hashing of a seed string combined
// with an incrementing index, ensuring uniqueness and unpredictability.
type MemoryRepository struct {
	mu           sync.RWMutex
	exports      map[string]*exportData
	files        map[string]*metadata.FileAttr
	parents      map[string]metadata.FileHandle
	children     map[string]map[string]metadata.FileHandle
	handleIndex  uint64
	mounts       map[mountKey]*metadata.MountEntry
	serverConfig metadata.ServerConfig
}

// NewMemoryRepository creates a new in-memory repository.
//
// The repository is initialized with empty maps for all storage structures.
// No exports or files are created by default - use AddExport to set up
// the filesystem structure.
//
// Returns:
//   - *MemoryRepository: A new repository instance ready for use
func NewMemoryRepository() *MemoryRepository {
	return &MemoryRepository{
		exports:     make(map[string]*exportData),
		files:       make(map[string]*metadata.FileAttr),
		parents:     make(map[string]metadata.FileHandle),
		children:    make(map[string]map[string]metadata.FileHandle),
		mounts:      make(map[mountKey]*metadata.MountEntry),
		handleIndex: 0,
	}
}

// handleToKey converts a FileHandle to a string key for map indexing.
//
// This is a simple type conversion that allows FileHandle ([]byte) to be
// used as a map key by converting it to a string.
//
// Parameters:
//   - handle: The file handle to convert
//
// Returns:
//   - string: String representation suitable for map indexing
func handleToKey(handle metadata.FileHandle) string {
	return string(handle)
}

// generateFileHandle creates a unique file handle using cryptographic hashing.
//
// The handle is generated by:
//  1. Combining a seed string with an incrementing index
//  2. Hashing the combination with SHA-256
//  3. Using the full 32-byte hash as the handle
//
// This approach ensures:
//   - Uniqueness: The incrementing index prevents collisions
//   - Unpredictability: The hash function makes handles non-guessable
//   - Fixed size: All handles are exactly 32 bytes
//
// Parameters:
//   - seed: A string to incorporate into the handle (typically a file path or name)
//
// Returns:
//   - FileHandle: A unique 32-byte file handle
func (r *MemoryRepository) generateFileHandle(seed string) metadata.FileHandle {
	r.handleIndex++
	data := fmt.Sprintf("%s-%d", seed, r.handleIndex)
	hash := sha256.Sum256([]byte(data))
	return hash[:]
}

// extractFileIDFromHandle extracts a file ID from a handle for directory listings.
//
// The file ID is a 64-bit unsigned integer derived from the first 8 bytes
// of the file handle. This provides:
//   - Stable file IDs across operations
//   - Efficient representation for directory entries
//   - Compatibility with NFS protocol requirements
//
// Parameters:
//   - handle: The file handle to extract from
//
// Returns:
//   - uint64: The extracted file ID, or 0 if handle is too short
func extractFileIDFromHandle(handle metadata.FileHandle) uint64 {
	if len(handle) < 8 {
		return 0
	}
	return binary.BigEndian.Uint64(handle[:8])
}
