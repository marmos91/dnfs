package metadata

import (
	"crypto/sha256"
	"encoding/binary"
	"fmt"
	"strings"

	"github.com/google/uuid"
)

// FileHandle is an opaque identifier for a file or directory.
//
// File handles are generated by the repository and used by protocol handlers
// to reference files and directories. They should be:
//   - Unique within the repository
//   - Unpredictable (for security)
//   - Fixed size or variable length (implementation choice)
//
// Protocol handlers may need to translate between FileHandle and protocol-specific
// handle formats (e.g., NFS file handles, SMB file IDs).
type FileHandle []byte

// ============================================================================
// Share-Aware Handle Encoding/Decoding
// ============================================================================

// EncodeFileHandle encodes a File into a FileHandle.
//
// Format: "<shareName>:<uuid>"
// Example: "/export:550e8400-e29b-41d4-a716-446655440000"
//
// This encoding allows NFS handlers to determine which share a file handle
// belongs to and retrieve the file's unique identifier. The handle is:
//   - Always under 64 bytes (NFS RFC 1813 compliant)
//   - Stable across server restarts (if metadata store persists UUIDs)
//   - Independent of file path (no length issues with deep hierarchies)
//
// Parameters:
//   - file: The file to encode into a handle
//
// Returns:
//   - FileHandle: Encoded file handle (max 45 bytes for typical share names)
//   - error: Error if handle would exceed 64 bytes (should never happen)
//
// Example:
//
//	file := &File{ID: uuid.New(), ShareName: "/export", Path: "/documents/report.pdf"}
//	handle := EncodeFileHandle(file)
//	// handle = "/export:550e8400-e29b-41d4-a716-446655440000"
func EncodeFileHandle(file *File) (FileHandle, error) {
	encoded := file.ShareName + ":" + file.ID.String()
	if len(encoded) > 64 {
		return nil, fmt.Errorf("file handle too long: %d bytes (max 64)", len(encoded))
	}
	return FileHandle([]byte(encoded)), nil
}

// EncodeShareHandle encodes a share name and UUID into a FileHandle.
//
// This is a lower-level version of EncodeFileHandle for cases where you have
// the shareName and UUID separately rather than a full File struct.
//
// Format: "<shareName>:<uuid>"
// Example: "/export:550e8400-e29b-41d4-a716-446655440000"
//
// Parameters:
//   - shareName: The name of the share (e.g., "/export")
//   - id: The UUID of the file
//
// Returns:
//   - FileHandle: Encoded file handle
//   - error: Error if handle would exceed 64 bytes (should never happen)
func EncodeShareHandle(shareName string, id uuid.UUID) (FileHandle, error) {
	encoded := shareName + ":" + id.String()
	if len(encoded) > 64 {
		return nil, fmt.Errorf("file handle too long: %d bytes (max 64)", len(encoded))
	}
	return FileHandle([]byte(encoded)), nil
}

// DecodeFileHandle decodes a FileHandle into its share name and UUID components.
//
// This is the inverse of EncodeShareHandle/EncodeFileHandle. It extracts the
// share name and UUID from a file handle so that handlers can:
//  1. Look up the correct share in the ShareRegistry
//  2. Retrieve the full File metadata using the UUID
//  3. Access the share's metadata and content stores
//
// Parameters:
//   - handle: The file handle to decode
//
// Returns:
//   - shareName: The name of the share
//   - id: The UUID of the file
//   - error: Error if the handle format is invalid or UUID is malformed
//
// Example:
//
//	shareName, id, err := DecodeFileHandle(handle)
//	if err != nil {
//	    return NFS3ERR_STALE
//	}
//	share := registry.GetShare(shareName)
//	file, err := share.MetadataStore.GetFileByID(ctx, id)
func DecodeFileHandle(handle FileHandle) (shareName string, id uuid.UUID, err error) {
	handleStr := string(handle)

	// Find the first colon separator
	idx := strings.Index(handleStr, ":")
	if idx == -1 {
		return "", uuid.Nil, fmt.Errorf("invalid file handle format: missing ':' separator")
	}

	shareName = handleStr[:idx]
	uuidStr := handleStr[idx+1:]

	if shareName == "" {
		return "", uuid.Nil, fmt.Errorf("invalid file handle: empty share name")
	}

	// Parse UUID
	id, err = uuid.Parse(uuidStr)
	if err != nil {
		return "", uuid.Nil, fmt.Errorf("invalid file handle: malformed UUID: %w", err)
	}

	return shareName, id, nil
}

// HandleToINode converts a FileHandle to a uint64 file ID (inode number).
//
// This is the CANONICAL implementation for converting file handles to inode
// numbers. All MetadataStore implementations and protocol handlers MUST use
// this function to ensure consistent inode numbers across the system.
//
// IMPORTANT FOR CUSTOM MetadataStore IMPLEMENTATIONS:
//
// If you implement your own MetadataStore, you MUST use this function when:
//  1. Populating file IDs for directory entries (ReadDirectory)
//  2. Generating inode numbers for file attributes
//  3. Any other operation that requires converting handles to numeric IDs
//
// Failure to use this function will result in:
//   - Inconsistent inode numbers between operations
//   - Circular directory structures (rm -rf failures)
//   - Client cache coherency issues
//   - find/ls reporting duplicate inodes
//
// Algorithm:
//
// Uses SHA-256 hash of the entire handle, taking the first 8 bytes as a
// uint64 in big-endian format. SHA-256 provides:
//   - Excellent collision resistance (critical for inode uniqueness)
//   - Deterministic output (same handle always produces same inode)
//   - Standard, well-tested algorithm
//   - Fast computation
//
// Parameters:
//   - handle: The file handle to convert (typically a path-based handle)
//
// Returns:
//   - uint64: File ID (inode number), or 0 if handle is empty
//
// Example:
//
//	handle := FileHandle([]byte("/export:/path/to/file.txt"))
//	inode := HandleToINode(handle)
//	// Use inode in directory entries or file attributes
func HandleToINode(handle FileHandle) uint64 {
	if len(handle) == 0 {
		return 0
	}

	// Compute SHA-256 hash of entire handle
	hash := sha256.Sum256(handle)

	// Use first 8 bytes as uint64 inode number (big-endian)
	return binary.BigEndian.Uint64(hash[:8])
}
