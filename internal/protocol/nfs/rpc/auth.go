package rpc

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

// Authentication Flavors
//
// RFC 5531 Section 8 defines authentication flavors used in RPC messages.
// Each RPC call includes credentials and verifiers that use these flavors
// to indicate the authentication mechanism being used.
const (
	// AuthNull indicates no authentication.
	// Used when the client doesn't need to authenticate or when the
	// underlying transport provides sufficient security.
	AuthNull uint32 = 0

	// AuthUnix indicates Unix-style authentication.
	// This is the most common authentication flavor for NFS, containing
	// the client's UID, GID, and supplementary group IDs.
	// Defined in RFC 1831 Section 9.2.
	AuthUnix uint32 = 1

	// AuthShort indicates short hand Unix credential.
	// This is an optimization where the server can issue a short-hand
	// credential after an AUTH_UNIX authentication, reducing overhead
	// in subsequent calls.
	AuthShort uint32 = 2

	// AuthDES indicates DES encryption-based authentication.
	// Provides stronger security using DES encryption for authentication.
	// Also known as AUTH_DH (Diffie-Hellman).
	AuthDES uint32 = 3
)

// UnixAuth represents Unix-style authentication credentials (AUTH_UNIX)
// as defined in RFC 1831 Section 9.2.
//
// AUTH_UNIX credentials provide the client's Unix identity, allowing the
// server to perform access control based on Unix file permissions. This is
// the standard authentication mechanism used by NFS implementations.
//
// Wire format (XDR):
//   - stamp:        unsigned int (4 bytes)
//   - machinename:  string (length + data + padding)
//   - uid:          unsigned int (4 bytes)
//   - gid:          unsigned int (4 bytes)
//   - gids:         unsigned int array (count + data)
//
// Security Note: AUTH_UNIX credentials are passed in cleartext and can be
// easily spoofed. They should only be used on trusted networks or in
// combination with secure transport mechanisms.
type UnixAuth struct {
	// Stamp is a timestamp or arbitrary ID generated by the client.
	// This field is not used for authentication but can help with
	// credential caching and debugging. In practice, clients often
	// use the current Unix timestamp or a random number.
	Stamp uint32

	// MachineName is the network name of the client machine.
	// This is typically the hostname as returned by gethostname().
	// Maximum recommended length is 255 bytes.
	MachineName string

	// UID is the user ID on the client machine.
	// This is the effective UID of the process making the RPC call.
	// The server uses this for access control decisions.
	UID uint32

	// GID is the primary group ID on the client machine.
	// This is the effective GID of the process making the RPC call.
	GID uint32

	// GIDs is a list of supplementary group IDs the user belongs to.
	// These are used in addition to the primary GID for access control.
	// RFC 1813 recommends limiting this to 16 groups, though some
	// implementations support more. Each element represents a group
	// the user is a member of on the client system.
	GIDs []uint32
}

// ParseUnixAuth parses AUTH_UNIX credentials from the opaque auth body.
//
// This function decodes the XDR-encoded authentication data from an RPC
// call message. The body parameter should be the raw bytes from the
// OpaqueAuth.Body field when the flavor is AUTH_UNIX.
//
// The function performs validation to prevent malicious or malformed
// credentials from causing issues:
//   - Machine name length is limited to 255 bytes
//   - Supplementary GID count is limited to 16
//   - XDR padding is properly handled for string alignment
//
// Parameters:
//   - body: Raw XDR-encoded AUTH_UNIX credential data
//
// Returns:
//   - *UnixAuth: Parsed Unix authentication credentials
//   - error: Parse error if the data is malformed or invalid
//
// Example usage:
//
//	if call.GetAuthFlavor() == rpc.AuthUnix {
//	    auth, err := rpc.ParseUnixAuth(call.GetAuthBody())
//	    if err != nil {
//	        return fmt.Errorf("parse unix auth: %w", err)
//	    }
//	    // Use auth.UID, auth.GID for access control
//	}
func ParseUnixAuth(body []byte) (*UnixAuth, error) {
	if len(body) == 0 {
		return nil, fmt.Errorf("empty auth body")
	}

	auth := &UnixAuth{}
	reader := bytes.NewReader(body)

	// Read stamp (4 bytes, big-endian)
	// This is an arbitrary client-generated identifier
	if err := binary.Read(reader, binary.BigEndian, &auth.Stamp); err != nil {
		return nil, fmt.Errorf("read stamp: %w", err)
	}

	// Read machine name length (4 bytes, big-endian)
	var nameLen uint32
	if err := binary.Read(reader, binary.BigEndian, &nameLen); err != nil {
		return nil, fmt.Errorf("read machine name length: %w", err)
	}

	// Validate machine name length to prevent excessive memory allocation
	// RFC doesn't specify a limit, but 255 is reasonable for hostnames
	if nameLen > 255 {
		return nil, fmt.Errorf("machine name too long: %d", nameLen)
	}

	// Read machine name bytes
	nameBytes := make([]byte, nameLen)
	if err := binary.Read(reader, binary.BigEndian, &nameBytes); err != nil {
		return nil, fmt.Errorf("read machine name: %w", err)
	}
	auth.MachineName = string(nameBytes)

	// Skip XDR padding to align to 4-byte boundary
	// XDR strings are padded to ensure the next field starts at a 4-byte boundary
	padding := (4 - (nameLen % 4)) % 4
	for i := uint32(0); i < padding; i++ {
		_, _ = reader.ReadByte()
	}

	// Read UID (4 bytes, big-endian)
	// This is the effective user ID on the client
	if err := binary.Read(reader, binary.BigEndian, &auth.UID); err != nil {
		return nil, fmt.Errorf("read uid: %w", err)
	}

	// Read GID (4 bytes, big-endian)
	// This is the effective primary group ID on the client
	if err := binary.Read(reader, binary.BigEndian, &auth.GID); err != nil {
		return nil, fmt.Errorf("read gid: %w", err)
	}

	// Read supplementary GIDs count (4 bytes, big-endian)
	var gidsLen uint32
	if err := binary.Read(reader, binary.BigEndian, &gidsLen); err != nil {
		return nil, fmt.Errorf("read gids length: %w", err)
	}

	// Validate GID count to prevent excessive memory allocation
	// RFC 1813 Section 2.5 suggests limiting to 16 groups for compatibility
	if gidsLen > 16 {
		return nil, fmt.Errorf("too many gids: %d", gidsLen)
	}

	// Read each supplementary GID (4 bytes each, big-endian)
	// These represent additional group memberships beyond the primary GID
	auth.GIDs = make([]uint32, gidsLen)
	for i := uint32(0); i < gidsLen; i++ {
		if err := binary.Read(reader, binary.BigEndian, &auth.GIDs[i]); err != nil {
			return nil, fmt.Errorf("read gid[%d]: %w", i, err)
		}
	}

	return auth, nil
}

// String returns a human-readable representation of the Unix auth credentials.
//
// This is useful for logging and debugging authentication-related issues.
// The format includes the machine name, UID, GID, and supplementary GIDs.
//
// Example output:
//
//	"UnixAuth{machine=client.example.com, uid=1000, gid=1000, gids=[4, 24, 27, 30]}"
func (u *UnixAuth) String() string {
	return fmt.Sprintf("UnixAuth{machine=%s, uid=%d, gid=%d, gids=%v}",
		u.MachineName, u.UID, u.GID, u.GIDs)
}
