package rpc

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

// Authentication flavor constants (RFC 5531 Section 8)
const (
	// AuthNull indicates no authentication
	AuthNull uint32 = 0

	// AuthUnix indicates Unix-style authentication
	AuthUnix uint32 = 1

	// AuthShort indicates short hand Unix credential
	AuthShort uint32 = 2

	// AuthDES indicates DES encryption-based authentication
	AuthDES uint32 = 3
)

// UnixAuth represents Unix-style authentication credentials (AUTH_UNIX)
// as defined in RFC 1831 Section 9.2
type UnixAuth struct {
	// Stamp is a timestamp (arbitrary ID generated by client)
	Stamp uint32

	// MachineName is the name of the client machine
	MachineName string

	// UID is the user ID on the client machine
	UID uint32

	// GID is the group ID on the client machine
	GID uint32

	// GIDs is a list of additional group IDs the user belongs to
	GIDs []uint32
}

// ParseUnixAuth parses AUTH_UNIX credentials from the opaque auth body
func ParseUnixAuth(body []byte) (*UnixAuth, error) {
	if len(body) == 0 {
		return nil, fmt.Errorf("empty auth body")
	}

	auth := &UnixAuth{}
	reader := bytes.NewReader(body)

	// Read stamp
	if err := binary.Read(reader, binary.BigEndian, &auth.Stamp); err != nil {
		return nil, fmt.Errorf("read stamp: %w", err)
	}

	// Read machine name (string)
	var nameLen uint32
	if err := binary.Read(reader, binary.BigEndian, &nameLen); err != nil {
		return nil, fmt.Errorf("read machine name length: %w", err)
	}

	if nameLen > 255 {
		return nil, fmt.Errorf("machine name too long: %d", nameLen)
	}

	nameBytes := make([]byte, nameLen)
	if err := binary.Read(reader, binary.BigEndian, &nameBytes); err != nil {
		return nil, fmt.Errorf("read machine name: %w", err)
	}
	auth.MachineName = string(nameBytes)

	// Skip padding for machine name
	padding := (4 - (nameLen % 4)) % 4
	for i := uint32(0); i < padding; i++ {
		reader.ReadByte()
	}

	// Read UID
	if err := binary.Read(reader, binary.BigEndian, &auth.UID); err != nil {
		return nil, fmt.Errorf("read uid: %w", err)
	}

	// Read GID
	if err := binary.Read(reader, binary.BigEndian, &auth.GID); err != nil {
		return nil, fmt.Errorf("read gid: %w", err)
	}

	// Read supplementary GIDs
	var gidsLen uint32
	if err := binary.Read(reader, binary.BigEndian, &gidsLen); err != nil {
		return nil, fmt.Errorf("read gids length: %w", err)
	}

	if gidsLen > 16 {
		return nil, fmt.Errorf("too many gids: %d", gidsLen)
	}

	auth.GIDs = make([]uint32, gidsLen)
	for i := uint32(0); i < gidsLen; i++ {
		if err := binary.Read(reader, binary.BigEndian, &auth.GIDs[i]); err != nil {
			return nil, fmt.Errorf("read gid[%d]: %w", i, err)
		}
	}

	return auth, nil
}

// String returns a human-readable representation of the Unix auth credentials
func (u *UnixAuth) String() string {
	return fmt.Sprintf("UnixAuth{machine=%s, uid=%d, gid=%d, gids=%v}",
		u.MachineName, u.UID, u.GID, u.GIDs)
}
